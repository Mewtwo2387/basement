--------------------------------------------------------------------------------
Instruction Set of the Virtual Machine of `basement-lang` [VERSION 0.2.1]
--------------------------------------------------------------------------------
PRELIMINARIES
-------------

Virtual Machine states
    The state of the virtual machine can be the following:
    - SUCCESS       (value: 0)
    - FAILURE       (value: 1)
    - RUNNING       (value: 2)
    - UNINITIALIZED (value: 3)
    Upon halting, these states are usually accompanied by a message string which
    can be printed onto either STDOUT or STDERR.


Word data
    In this virtual machine, a "word" has the size of 64 bits or 8 bytes.
    From hereon, the size of a word in bytes shall be referred to as `W`.


Immediate arguments for instructions
    - <LITERAL>
        A constant value of size `W` bytes supplied by the user in the code.
    - <ADDRESS>
        Memory address of size `W` bytes.


--------------------------------------------------------------------------------
INSTRUCTIONS
------------

Stack manipulation instructions
    PUSH & POP instructions:
        - LOAD_CONST, <LITERAL>
            Push the immediate argument to the stack.
        - LOAD_ADDR, <ADDRESS>
            Push the value addressed by the immediate argument to the stack.
        - STORE_ADDR, <ADDRESS>
            Pop the top element of the stack and store it to memory addressed by
            the immediate argument.
        - LOAD
            Pop an address from the stack and push the value the address points
            to to the stack.
        - STORE
            Pop an address and a literal value. And use them to write to memory.
        - POP_RES
            Pop the top element of the stack and set it as the VM result.
    Miscellaneous:
        - DISCARD
            Remove the top element of the stack.
        - DUP
            Duplicate the top element of the stack.
        - SWAP_TOP
            Swap the two topmost elements on the stack.
        - SWAP, <LITERAL>
            Swap the top element of the stack with another element in the stack
            with the immediate argument as the offset from the top.
            NOTE: Since the stack grows downwards, the offset value is positive.


Function instructions:
    - CALL, <ADDRESS>
        Jump the execution to the address of the function. Prior to this,
        several instructions are to be done:
            1. Push a reserved return value.
            2. Push the function arguments.
            3. Push the number of arguments.
            4. Push the return address which at this point should be the current
               instruction pointer.
        The sequence of data that is pushed to the stack shall be referred to as
        the "call frame".
        After the jump has been executed, the frame pointer moves to the top of
        the stack, which should have the return address.
    - RET
        Return the execution from the function. This instruction execute the
        following instructions:

        1. Swap the top element of the stack with the reserved return value at
           the bottom of the topmost call frame. The return value is accessed
           through the frame pointer by calculating its address:

                    `FP + (N + 1)*W`

           where `N` is the number of arguments and `FP` is the frame pointer.
           (Note that the stack grows downwards so a "decrement" amounts to
            adding an offset to the address.)

           If the stack pointer is the same as the frame pointer, i.e. the
           execution of the function resulted to no value,
           no swapping is done.

        2. The stack pointer is decremented by `(N + 1)*W` such that it points
           to the return value.
        3. Then the instruction pointer is set as the return address, acccessed
           through the frame pointer.
        4. The frame pointer is then set to equal to the stack pointer.
           This action effectively pops off the call frame from the stack.


Arithmetic logical operation instructions
    Binary operations:
        Pop two values from the stack, perform the binary operation,
        and push the result to the stack.
        - ADD  (addition)
        - SUB  (subtraction)
        - MUL  (multiplication)
        - DIV  (integer division)
    In-place binary operations:
        - ADD_CONST, <LITERAL>
            Add the immediate argument with the top element of the stack.
        - ADD_ADDR, <ADDRESS>
            Get the value addressed by the immediate argument and add it to the
            top element of the stack.
        - SUB_CONST, <LITERAL>
            Subtract the immediate argument with the top element of the stack.
        - SUB_ADDR, <ADDRESS>
            Get the value addressed by the immediate argument and subtract it to
            the top element of the stack.
    Unary operations
        Pop one value from the stack and do the unary operation on it.
        The result is then pushed to the stack.
        - UN_POSITIVE
            Does not do anything to the number. Akin to NOP.
        - UN_NEGATIVE
            "Negate" the value on top of the stack. This is equivalent to the
            following bitwise operation:    
                `~n + 1`
            where `~` is the bitwise NOT operation and `n` is the operand to be
            negated.


Bitwise logical operation instructions
    Binary operations:
        (Same case as the arithmetic binary operations)
        - OR   (bitwise inclusive OR)
        - AND  (bitwise AND)
        - NOR  (bitwise not OR)
        - NAND (bitwise not AND)
        - XOR  (bitwise exclusive OR)
        - LSH  (bitwise left-shift)
        - RSH  (bitwise right-shift)
    Unary operations:
        Pop one value from the stack and do the unary operation on it.
        The result is to be pushed to the stack.
        - NOT  (bitwise NOT)


Comparison operation instructions:
    Binary operations:
        (Same case as the arithmetic/bitwise logical binary operations)
        If the result is true, the pushed value is 1, and if it is false,
        the pushed value is 0.
        - EQ  (Equal)
        - LT  (Less than)
        - LEQ (Less than or equal to)
        - GT  (Greater than)
        - GEQ (Greater than or equal to)


Input/Output instructions:
    IN:
        Get a value from the STDIN and push it to the stack.
    OUT_CHAR:
        Pop a value from the stack and print it to STDOUT as an ASCII character.
    OUT_NUM:
        Pop a value from the stack and print it to STDOUT as a base-16 integer.
    OUT_IP:
        Print the instruction pointer as a base-16 integer.
    OUT_SP:
        Print the stack pointer as a base-16 integer.
    OUT_ADDR, <ADDRESS>:
        Print the value addressed by the immediate argument as a base-16 integer


Jump instructions:
    - JUMP_ADDR, <ADDRESS>
        Unconditional jump to the address supplied by the immediate argument.
    - JMPZ_ADDR, <ADDRESS>
        Jump to the address supplied by the immediate argument if the top
        element of the stack is 0 (i.e. if it is false)
    - JMPNZ_ADDR, <ADDRESS>
        Jump to the address supplied by the immediate argument if the top
        element of the stack is NOT 0 (i.e. if it is true)
    - JUMP
        Pop an address from the stack and unconditionally jump to it.
    - JMPZ
        Pop an address from the stack. If the value on top of the stack is 0,
        jump to the address. Otherwise, skip to the next instruction.
    - JMPNZ
        Pop an address from the stack. If the value on top of the stack is not 0
        jump to the address. Otherwise, skip to the next instruction.


CPU state instructions:
    - ABORT
        Fatally stop the code execution. Usually executed under unexpected or
        abnormal circumstances (e.g. IP going out of bounds).
        The end state of the VM will always be FAILURE.
    - DONE
        Stop the code execution. Usually executed under normal circumstances.
        The end state of the VM is determined by a default value or by the code,
        usually by the `POP_RES` instruction.
        By default, the end state is SUCCESS which has the value of 0.


Miscellaneous:
    - NOP
        No operation. The execution proceeds to the next instruction.

--------------------------------------------------------------------------------
NOTES:
    1.) To simplify further the VM implementation, all data including the memory
        addresses will have the same size: 64 bits.
        That is to say, we abandon the original word size of 1 byte.
        However, the opcodes will still be 1 byte long.